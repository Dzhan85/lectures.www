Сокеты
======

.. seealso::

    * `<https://ru.wikipedia.org/wiki/Сокет_(программный_интерфейс)>`_
    * `<https://ru.wikipedia.org/wiki/Сокеты_Беркли>`_
    * http://rsdn.ru/article/unix/sockets.xmlhttp://rsdn.ru/article/unix/sockets.xml
    * http://pymotw.com/2/socket/index.html
    * http://masandilov.ru/network/guide_to_network_programming

Сокеты (англ. socket — разъём) — название программного интерфейса для обеспечения обмена данными между процессами. Процессы при таком обмене могут исполняться как на одной ЭВМ, так и на различных ЭВМ, связанных между собой сетью. Сокет — абстрактный объект, представляющий конечную точку соединения.

Принципы сокетов
----------------

Каждый процесс может создать слушающий сокет (серверный сокет) и привязать его к какому-нибудь порту операционной системы (в UNIX непривилегированные процессы не могут использовать порты меньше 1024). Слушающий процесс обычно находится в цикле ожидания, то есть просыпается при появлении нового соединения. При этом сохраняется возможность проверить наличие соединений на данный момент, установить тайм-аут для операции и т.д.

Каждый сокет имеет свой адрес. ОС семейства UNIX могут поддерживать много типов адресов, но обязательными являются INET-адрес и UNIX-адрес. Если привязать сокет к UNIX-адресу, то будет создан специальный файл (файл сокета) по заданному пути, через который смогут сообщаться любые локальные процессы путём чтения/записи из него (см. Доменный сокет Unix). Сокеты типа INET доступны из сети и требуют выделения номера порта.

Обычно клиент явно подсоединяется к слушателю, после чего любое чтение или запись через его файловый дескриптор будут передавать данные между ним и сервером.

Основные функции
----------------

+----------------+--------------------------------------------------------+
| **Общие**      |                                                        |
+----------------+--------------------------------------------------------+
| Socket         | Создать новый сокет и вернуть файловый                 |
|                | дескриптор                                             |
+----------------+--------------------------------------------------------+
| Send           | Отправить данные по сети                               |
+----------------+--------------------------------------------------------+
| Receive        | Получить данные из сети                                |
+----------------+--------------------------------------------------------+
| Close          | Закрыть соединение                                     |
+----------------+--------------------------------------------------------+
|                |                                                        |
+----------------+--------------------------------------------------------+
| **Серверные**  |                                                        |
+----------------+--------------------------------------------------------+
| Bind           | Связать сокет с IP-адресом и портом                    |
+----------------+--------------------------------------------------------+
| Listen         | Объявить о желании принимать соединения.               |
|                | Слушает порт и ждет когда будет установлено соединение |
+----------------+--------------------------------------------------------+
| Accept         | Принять запрос на установку соединения                 |
+----------------+--------------------------------------------------------+
|                |                                                        |
+----------------+--------------------------------------------------------+
| **Клиентские** |                                                        |
+----------------+--------------------------------------------------------+
| Connect        | Установить соединение                                  |
+----------------+--------------------------------------------------------+

socket()
--------

.. seealso::

    * http://unixhelp.ed.ac.uk/CGI/man-cgi?socket+2
    * https://docs.python.org/3.5/library/socket.html#socket.socket

Создаёт конечную точку соединения и возвращает дескриптор
и принимает три аргумента:

#. **domain** указывающий семейство протоколов создаваемого сокета

   *  **AF_INET** для сетевого протокола IPv4
   *  **AF_INET6** для IPv6
   *  **AF_UNIX** для локальных сокетов (используя файл)

#. **type**

   * **SOCK_STREAM** (надёжная потокоориентированная служба (сервис) или потоковый сокет)
   * **SOCK_DGRAM** (служба датаграмм или датаграммный сокет)
   * **SOCK_RAW** (Сырой сокет — сырой протокол поверх сетевого уровня).

#. **protocol**

   Протоколы обозначаются символьными константами с префиксом **IPPROTO_*** (например, **IPPROTO_TCP** или **IPPROTO_UDP**). Допускается значение protocol=0 (протокол не указан), в этом случае используется значение по умолчанию для данного вида соединений.

.. note::

    Функция возвращает −1 в случае ошибки. Иначе, она возвращает целое число, представляющее присвоенный дескриптор.

Пример на Си

.. no-code-block:: cpp

    #include <sys/types.h>
    #include <sys/socket.h>

    int socket(int domain, int type, int protocol);

Пример на Python

.. code-block:: python

   import socket

   # Создание объекта сокета.
   sock_obj = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)

   # AF_INET, SOCK_STREAM и 0 используются по умолчанию при создании сокета.
   # Поэтому можно просто писать:
   sock_obj = socket.socket()

bind()
------

.. seealso::

    * http://unixhelp.ed.ac.uk/CGI/man-cgi?bind+2
    * https://docs.python.org/3.5/library/socket.html#socket.socket.bind

Связывает сокет с конкретным адресом. Когда сокет создается при помощи socket(), он ассоциируется с некоторым семейством адресов, но не с конкретным адресом. До того как сокет сможет принять входящие соединения, он должен быть связан с адресом. bind() принимает три аргумента:

#. **sockfd** — дескриптор, представляющий сокет при привязке
#. **serv_addr** — указатель на структуру sockaddr, представляющую адрес, к которому привязываем.
#. **addrlen** — поле socklen_t, представляющее длину структуры sockaddr.

.. note::

    Возвращает 0 при успехе и −1 при возникновении ошибки.

Пример на Си

.. no-code-block:: cpp

    #include <sys/types.h>
    #include <sys/socket.h>

    int bind(int sockfd, const struct sockaddr *my_addr, socklen_t addrlen);

Пример на Python

.. code-block:: python

    server_address = ('localhost', 8080)
    sock_obj.bind(server_address)  # Привязка адреса и порта к сокету.

Автоматическое получение имени хоста.

.. code-block:: python

    host = socket.gethostname()     # Получить имя локальной машины.
    server_address = (host, 8080)
    sock_obj.bind(server_address)   # Привязка адреса и порта к сокету.

listen()
--------

.. seealso::

    * http://unixhelp.ed.ac.uk/CGI/man-cgi?listen+2
    * https://docs.python.org/3.5/library/socket.html#socket.socket.listen

Подготавливает привязываемый сокет к принятию входящих соединений. Данная функция применима только к типам сокетов SOCK_STREAM и SOCK_SEQPACKET. Принимает два аргумента:

#. **sockfd** — корректный дескриптор сокета.
#. **backlog** — целое число, означающее число установленных соединений, которые могут быть обработаны в любой момент времени. Операционная система обычно ставит его равным максимальному значению.

.. note::

    После принятия соединения оно выводится из очереди. В случае успеха возвращается 0, в случае возникновения ошибки возвращается −1.

Пример на Си

.. no-code-block:: cpp

    #include <sys/socket.h>
    int listen(int sockfd, int backlog);

Пример на Python

.. code-block:: python

    sock_obj.listen(5)  # Ждем соединение клиента.

accept()
--------

.. seealso::

    * http://unixhelp.ed.ac.uk/CGI/man-cgi?accept+2
    * https://docs.python.org/3.5/library/socket.html#socket.socket.accept

Используется для принятия запроса на установление соединения от удаленного хоста. Принимает следующие аргументы:

#. **sockfd** — дескриптор слушающего сокета на принятие соединения.
#. **cliaddr** — указатель на структуру sockaddr, для принятия информации об адресе клиента.
#. **addrlen** — указатель на socklen_t, определяющее размер структуры, содержащей клиентский адрес и переданной в accept(). Когда accept() возвращает некоторое значение, socklen_t указывает сколько байт структуры cliaddr использовано в данный момент.

.. note::

    Функция возвращает дескриптор сокета, связанный с принятым соединением, или −1 в случае возникновения ошибки.

Пример на Си

.. code-block:: cpp

    #include <sys/types.h>
    #include <sys/socket.h>
    int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);

Пример на Python

.. code-block:: python

    conn, addr = sock_obj.accept()  # Установление соединения с клиентом.

connect()
---------

.. seealso::

    * http://unixhelp.ed.ac.uk/CGI/man-cgi?connect+2
    * https://docs.python.org/3.5/library/socket.html#socket.socket.connect

Устанавливает соединение с сервером.

Некоторые типы сокетов работают без установления соединения, это в основном касается UDP-сокетов. Для них соединение приобретает особое значение: цель по умолчанию для посылки и получения данных присваивается переданному адресу, позволяя использовать такие функции как send() и recv() на сокетах без установления соединения.

Загруженный сервер может отвергнуть попытку соединения, поэтому в некоторых видах программ необходимо предусмотреть повторные попытки соединения.

.. note::

    Возвращает целое число, представляющее код ошибки: 0 означает успешное выполнение, а −1 свидетельствует об ошибке.

Пример на Си

.. code-block:: cpp

    #include <sys/types.h>
    #include <sys/socket.h>
    int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);

Пример на Python

.. code-block:: python

    server_address = ('192.168.1.100', 8080)
    sock_obj.connect(server_address)

Передача данных
---------------

Для передачи данных можно пользоваться стандартными функциями чтения/записи файлов read и write, но есть специальные функции для передачи данных через сокеты:

* send
* recv
* sendto
* recvfrom
* sendmsg
* recvmsg

Нужно обратить внимание, что при использовании протокола TCP (сокеты типа SOCK_STREAM) есть вероятность получить меньше данных, чем было передано, так как ещё не все данные были переданы, поэтому нужно либо дождаться, когда функция recv возвратит 0 байт, либо выставить флаг MSG_WAITALL для функции recv, что заставит её дождаться окончания передачи. Для остальных типов сокетов флаг MSG_WAITALL ничего не меняет (например, в UDP весь пакет = целое сообщение).

send()
------

.. seealso::

    * http://unixhelp.ed.ac.uk/CGI/man-cgi?send+2
    * https://docs.python.org/3.5/library/socket.html#socket.socket.send

**send**, **sendto** - отправка данных.

Пример на Си

.. code-block:: cpp

   #include <sys/types.h>
   #include <sys/socket.h>

   ssize_t send(int s, const void *buf, size_t len, int flags);
   ssize_t sendto(int  s, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen);

Пример на Python

.. code-block:: python

   IP = '192.168.1.100'
   PORT = 8080

   sock_obj.send('Hello World!')
   sock_obj.sendto('Hello World!', (IP, PORT))

resv()
------

.. seealso::

    * http://unixhelp.ed.ac.uk/CGI/man-cgi?recv+2
    * https://docs.python.org/3.5/library/socket.html#socket.socket.recv

**recv**, **recvfrom** - чтение данных из сокета.

Пример на Си

.. code-block:: cpp

   #include <sys/types.h>
   #include <sys/socket.h>

   ssize_t recv(int s, void *buf, size_t len, int flags);
   ssize_t recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen);

Пример на Python

.. code-block:: python

   BUFFER_SIZE = 1024

   data = conn.recv(BUFFER_SIZE)
   data, sender_addr = conn.recvfrom(BUFFER_SIZE)

SOCK_STREAM vs SOCK_DGRAM
-------------------------

.. seealso::

    * `UDP <http://www.soslan.ru/tcp/tcp11.html>`_
    * `TCP <http://www.soslan.ru/tcp/tcp17.html>`_

.. figure:: /_static/4.net/stream_datagram_socket.*
   :width: 300pt
   :align: center

+--------------------------------------+----------------------------+
| Потоковый (SOCK_STREAM)              | Дейтаграммный (SOCK_DGRAM) |
+======================================+============================+
| Устанавливает соединение             | Нет                        |
+--------------------------------------+----------------------------+
| Гарантирует доставку данных          | Нет в случае UDP           |
+--------------------------------------+----------------------------+
| Гарантирует порядок доставки пакетов | Нет в случае UDP           |
+--------------------------------------+----------------------------+
| Гарантирует целостность пакетов      | Тоже                       |
+--------------------------------------+----------------------------+
| Разбивает сообщение на пакеты        | Нет                        |
+--------------------------------------+----------------------------+
| Контролирует поток данных            | Нет                        |
+--------------------------------------+----------------------------+

TCP гарантирует доставку пакетов, их очередность, автоматически разбивает
данные на пакеты и контролирует их передачу, в отличии от UDP.
Но при этом TCP работает медленнее за счет повторной передачи потерянных
пакетов и большему количеству выполняемых операций над пакетами. Поэтому
там где требуется гарантированная доставка (Веб-браузер, telnet, почтовый клиент) используется TCP, если же требуется передавать данные в реальном
времени (многопользовательские игры, видео, звук) используют UDP.
