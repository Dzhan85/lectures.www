Реляционная модель данных
=========================

.. seealso:: Michael Bayer:
  `Introduction to SQLAlchemy <https://bitbucket.org/zzzeek/pycon2013_student_package>`_

Этот документ является переводом части лекции Майка Байера (Michael Bayer) о SQLAlchemy, которая была представлена на Pycon 2013.

Реляционная модель
------------------

Модель представляет собой фиксированную структуру математических понятий, которая описывает то, как будут представлены данные. Базовой единицей данных в пределах реляционной модели является таблица.

Таблица
^^^^^^^

.. figure:: /_static/2.databases/rdb/review_table.png
   :align: center

Таблица - это базовая единица данных. В реляционной алгебре она называется "отношение" (relation). Состоит из столбцов (columns), которые определяют конкретные типы данных. Данные в таблице организованы в строки (rows), которые содержат множества значений столбцов.

Язык описания данных (DDL)
^^^^^^^^^^^^^^^^^^^^^^^^^^

В SQL для создания таблицы используется оператор CREATE TABLE. Этот оператор является примером языка описания данных (DDL). DDL служит для описания структуры базы данных. Пример использования:

.. code-block:: sql

  CREATE TABLE employee (
    emp_name VARCHAR(30),
    dep_id INTEGER
  )

Первичные ключи
^^^^^^^^^^^^^^^

При создании таблицы могут быть использованы различные "ограничения" (constraints), которые содержат правила, указывающие, какие данные представлены в ней. Одним из самых используемых ограничений является первичный ключ (primary key constraint), который гарантирует, что каждая строка таблицы должна содержать уникальное значение. Первичный ключ может состоять из одного или нескольких столбцов. Первичные ключ, состоящие из нескольких столбцов, также называются "составными" (composite).

Правильным считается наличие первичного ключа во всех таблицах базы данных. При этом существует два варианта первичных ключей: искусственный (surrogate primary key) и естественный (natural primary key).

Первый вариант обычно представляет собой целочисленный идентификатор. Применяется там где нет возможности использовать натуральный первичный ключ. Позволяют решать те же практические задачи, что и естественные: улучшение производительности памяти и индексов при операциях обновления.

Второй же вариант представляет собой данные, которые уже присутствуют в описываемой предметной области. Например, почтовые индексы могут быть использованы как естественные первичные ключи без дополнительной обработки. Их использование, если, конечно, оно возможно, считается более правильным, чем искусственных.

Пример создания первичного ключа:

.. code-block:: sql

  CREATE TABLE employee (
    emp_id INTEGER,
    emp_name VARCHAR(30),
    dep_id INTEGER,
    PRIMARY KEY (emp_id)
  )

.. _ForeignKeys:

Внешние ключи
^^^^^^^^^^^^^

В то время как одна таблица имеет первичный ключ, другая таблица может иметь ограничение, описывающее, что её строки ссылаются на гарантированно существующие строки в первой таблице. Это реализуется через создание в "удалённой" таблице ("потомке") столбца (может быть и несколько), значениями которого являются значения первичного ключа из "локальной" таблицы ("родителя"). Вместе наборы этих столбцов составляют внешний ключ (foreign key constraint), который является механизмом базы данных, гарантирующим что значения в "удалённых" столбцах присутствуют как первичные ключи в "локальных". Это ограничение контролирует все операции на этих таблицах: добавление / изменение данных в "удалённой" таблице; удаление / изменение данных в "родительской" таблице. Внешний ключ проверяет, чтобы данные корректно присутствовали в обоих таблицах. Иначе операции будут отменены.

Внешние ключи могут быть составными, если входящие в них первичные ключи являются таковыми.

В примере представлена таблица "department", которая связана с таблицей "employee" через отношение столбцов "employee.dep_id" и "department.dep_id":

.. figure:: /_static/2.databases/rdb/review_foreignkey.png
   :align: center

Представленная на рисунке связь может быть описана через DDL следующим образом:

.. code-block:: sql

  CREATE TABLE department (
    dep_id INTEGER,
    dep_name VARCHAR(30),
    PRIMARY KEY (dep_id)
  )

  CREATE TABLE employee (
    emp_id INTEGER,
    emp_name VARCHAR(30),
    dep_id INTEGER,
    PRIMARY KEY (emp_id),
    FOREIGN KEY (dep_id)
      REFERENCES department(dep_id)
  )

Нормализация
^^^^^^^^^^^^

Реляционная модель базируется на реляционной алгебре, одним из ключевых понятий которой является нормализация.

Основной идея нормализации в исключении повторяющихся данных так, чтобы конкретная часть данных была представлена только в одном месте. Этот подход позволяет упростить данные до максимально атомарного вида, с которым намного проще работать: искать, производить какие-либо операции.

Классический пример денормализованных данных:

.. list-table:: Employee Language
    :header-rows: 1

    * - name
      - language
      - department
    * - Dilbert
      - C++
      - Systems
    * - Dilbert
      - Java
      - Systems
    * - Wally
      - Python
      - Engineering
    * - Wendy
      - Scala
      - Engineering
    * - Wendy
      - Java
      - Engineering

Строки в этой таблице могут быть уникально идентифицированы по столбцам "name" и "language", которые являются потенциальным ключом. По теории нормализации таблица из примера нарушает вторую нормальную форму. Потому как
неосновной атрибут "department" логически связан только со столбцом "name". Правильная нормализация в данном случае выглядит следующим образом:

.. list-table:: Employee Department
    :header-rows: 1

    * - name
      - department
    * - Dilbert
      - Systems
    * - Wally
      - Engineering
    * - Wendy
      - Engineering

.. list-table:: Employee Language
    :header-rows: 1

    * - name
      - language
    * - Dilbert
      - C++
    * - Dilbert
      - Java
    * - Wally
      - Python
    * - Wendy
      - Scala
    * - Wendy
      - Java

Теперь наглядно видно, как вторая форма улучшила структуру данных. Изначально пример содержал повторы связок полей "name" и "department" так часто, как часто встречался уникальный для данного имени "язык". Улучшенный же вариант сделал связки "name/department" и "name/language" независимыми друг от друга.

Ограничения данных, такие как первичные и внешние ключи, предназначены как раз для достижения состояния нормализации. Для примера выше это будет выглядеть так:

* "Employee Department -> name" - первичный ключ;
* "Employee Language -> name, language" - составной первичный ключ;
* "Employee Language -> name", в свою очередь, - внешний ключ, на поле "Employee Department -> name".

Если таблицу удаётся сходу свернуть в отношения ключей, то это, зачастую, значит, что она не нормализована.

Язык управления данными (DML)
-----------------------------

После того как определена схема базы данных и таблиц, в них можно помещать данные и изменять их с помощью DML, который реализован частью конструкций SQL. Далее будут подробно разобраны основные из этих конструкций.

Вставка (insert)
^^^^^^^^^^^^^^^^

Новые строки добавляются с помощью команды **INSERT**. Эта команда содержит часть *VALUES*, в которой прописаны данные для каждой добавляемой строки:

.. code-block:: sql

    INSERT INTO employee (emp_id, emp_name, dep_id)
        VALUES (1, 'dilbert', 1);

    INSERT INTO employee (emp_id, emp_name, dep_id)
        VALUES (2, 'wally', 1);

.. topic:: Автоинкрементные целочисленные ключи

    Большинство современных баз данных содержит в себе функционал для генерации инкрементных целочисленных значений, которые обычно используются в качестве искусственных первичных ключей. Как в примере с таблицами "employee" и "department". Например, при использовании :ref:`SQLite`, столбец ``emp_id`` в коде выше будет автоматически создан целочисленным; при использовании MySQL для создания автоинкрементных ключей используется опция **AUTO INCREMENT**; в PostgreSQL для этих целей служит тип данных **SERIAL**. Когда используются генераторы автоинкрементных первичных ключей, можно опустить эти столбцы в команде **INSERT**:

    .. code-block:: sql

        INSERT INTO employee (emp_name, dep_id)
            VALUES ('dilbert', 1);

        INSERT INTO employee (emp_name, dep_id)
            VALUES ('wally', 1);

    Базы данных с этой функциональностью также позволяют получить сгенерированное при вставке значение. При этом используются нестандартные для SQL конструкции и / или функции. Например, в PostgreSQL это параметр **RETURNING**:

    .. code-block:: sql

          INSERT INTO employee (emp_name, dep_id)
              VALUES ('dilbert', 1) RETURNING emp_id;

    .. list-table::
        :header-rows: 1

        * - emp_id
        * - 1

Обновление (Update)
^^^^^^^^^^^^^^^^^^^

Команда **UPDATE** служит для изменения данных в существующих строках, использую параметр *WHERE* для фильтрации строк по какому-либо условию и параметр *SET* для установки нового значения в нужный столбец:

.. code-block:: sql

    UPDATE employee SET dep_id=7 WHERE emp_name='dilbert'

Когда команда **UPDATE** выполняется по условию, как в примере выше, в результате может быть изменено любое количество строк. В том числе и ни одна. Обычно присутствует некоторый счётчик строк, который позволяет получить информацию о том, сколько строк было отфильтровано и, как следствие, изменено.

Удаление (Delete)
^^^^^^^^^^^^^^^^^

Команда **DELETE** служит для удаления строк. Также как и **UPDATE** использует параметр *WHERE* для выборки нужных строк:

.. code-block:: sql

    DELETE FROM employee WHERE dep_id=1

Запросы (Queries)
-----------------

Ключевой особенностью SQL является возможность построения запросов к данным. Для этого используется команда **SELECT**. Также как и в командах **UPDATE** и **DELETE** в ней присутствует параметр *WHERE*.

.. figure:: /_static/2.databases/rdb/review_select.png
    :align: center

Например, можно выбрать строки у которых ``dep_id`` равен ``12``:

.. code-block:: sql

    SELECT emp_id, emp_name FROM employee WHERE dep_id=12

Команда **SELECT** из примера выше имеет следующие части:

1. Параметр *FROM* указывает таблицы, из которых выбираются строки.
2. Параметр *WHERE* используется для фильтрации выбираемых строк по какому-либо условию.
3. Между словами SELECT и FROM расположен список столбцов, которые необходимо показать из каждой отфильтрованной строки.

Результат примера может выглядеть как-то так:

.. list-table::
    :header-rows: 1

    * - emp_id
      - emp_name
    * - 1
      - wally
    * - 2
      - dilbert
    * - 5
      - wendy

Сортировка (ordering)
^^^^^^^^^^^^^^^^^^^^^

К команде **SELECT** можно добавить параметр *ORDER BY* задающий по какому полю сортировать результаты:

.. code-block:: sql

    SELECT emp_id, emp_name FROM employee WHERE dep_id=12 ORDER BY emp_name

.. list-table::
    :header-rows: 1

    * - emp_id
      - emp_name
    * - 2
      - dilbert
    * - 1
      - wally
    * - 5
      - wendy

Объединения (joins)
^^^^^^^^^^^^^^^^^^^

Запросы могут использовать механизм объединений для строк из двух таблиц и представления их как одна строка. Обычно объединение производится по :ref:`внешним ключам <ForeignKeys>`.

Параметр *JOIN* помещается внутри блока *FROM*, между именами объединяемых таблиц. Он, в свою очередь, в себе содержит параметр *ON*, который отвечает за критерий объединения строк из разных таблиц.

.. figure:: /_static/2.databases/rdb/review_join.png
    :align: center

*JOIN* создаёт промежуточную структуру табличного вида. Она содержит в себе объединенные данные из обоих таблиц.

Используя примеры с таблицами Department и Employee, выберем сотрудников вместе с названиями их отделов:

.. code-block:: sql

    SELECT e.emp_id, e.emp_name, d.dep_name
      FROM employee AS e
        JOIN department AS d
        ON e.dep_id=d.dep_id
      WHERE d.dep_name = 'Software Artistry'

.. list-table::
    :header-rows: 1

    * - emp_id
      - emp_name
      - dep_name
    * - 2
      - dilbert
      - Software Artistry
    * - 1
      - wally
      - Software Artistry
    * - 5
      - wendy
      - Software Artistry
