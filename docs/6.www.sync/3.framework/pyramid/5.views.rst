Функционал (Views)
==================

Блог
----

Создадим представления для нашего блога. Пока в виде "заглушек".

.. code-block:: python

   from pyramid.view import view_config


   @view_config(route_name='blog',
                renderer='blog/index.jinja2')
   def index_page(request):
       return {}


   @view_config(route_name='blog_article', renderer='blog/read.jinja2')
   def blog_view(request):
       return {}


   @view_config(route_name='blog_action', match_param='action=create',
                renderer='blog/edit.jinja2')
   def blog_create(request):
       return {}


   @view_config(route_name='blog_action', match_param='action=edit',
                renderer='blog/edit.jinja2')
   def blog_update(request):
       return {}


   @view_config(route_name='auth', match_param='action=in', renderer='string',
                request_method='POST')
   @view_config(route_name='auth', match_param='action=out', renderer='string')
   def sign_in_out(request):
       return {}

Главная страница
~~~~~~~~~~~~~~~~

``views.py``

.. code-block:: python

   @view_config(route_name='blog',
                renderer='blog/index.jinja2')
   def index_page(request):
       page = int(request.params.get('page', 1))
       paginator = Article.get_paginator(request, page)
       return {'paginator': paginator}

``models.py`` ``Article``

.. code-block:: python

    @classmethod
    def get_paginator(cls, request, page=1):
        query = Session.query(Article).order_by(desc(Article.created))
        query_params = request.GET.mixed()

        def url_maker(link_page):
            query_params['page'] = link_page
            return request.current_route_url(_query=query_params)
        return SqlalchemyOrmPage(query, page, items_per_page=5,
                                 url_maker=url_maker)

Просмотр статей
~~~~~~~~~~~~~~~

``views.py``

.. code-block:: python

   @view_config(route_name='blog_article', renderer='blog/read.jinja2')
   def blog_view(request):
       id = int(request.matchdict.get('id', -1))
       article = Article.by_id(id)
       if not article:
           return HTTPNotFound()
       return {'article': article}

``models.py`` ``Article``

.. code-block:: python

    @classmethod
    def by_id(cls, id):
        return Session.query(Article).filter(Article.id == id).first()

Создание и редактирование
~~~~~~~~~~~~~~~~~~~~~~~~~

``forms.py``

.. code-block:: python

   import deform
   import colander


   def get_session(request):
       return request.environ.get('paste.session.factory', lambda: {})()


   def get_csrf_token(session):
       if 'csrf' not in session:
           from uuid import uuid4
           session['csrf'] = uuid4().hex
       return session['csrf']


   def get_form(request):
       session = get_session(request)
       session['csrf'] = get_csrf_token(session)
       schema = CreateArticle().bind(request=request)
       submit = deform.Button(name='submit',
                              css_class='blog-form__button')
       return deform.Form(schema, buttons=(submit,))


   @colander.deferred
   def deferred_csrf_default(node, kw):
       request = kw.get('request')
       session = get_session(request)
       csrf_token = get_csrf_token(session)
       return csrf_token


   @colander.deferred
   def deferred_csrf_validator(node, kw):
       def validate_csrf_token(node, value):
           request = kw.get('request')
           session = get_session(request)
           csrf_token = get_csrf_token(session)
           if value != csrf_token:
               raise colander.Invalid(node, 'Bad CSRF token')

       return validate_csrf_token


   class CSRFSchema(colander.Schema):
       csrf = colander.SchemaNode(colander.String(),
                                  default=deferred_csrf_default,
                                  validator=deferred_csrf_validator,
                                  widget=deform.widget.HiddenWidget(), )


   class CreateArticle(colander.Schema):
       title = colander.SchemaNode(colander.String())
       content = colander.SchemaNode(
           colander.String(),
           widget=deform.widget.TextAreaWidget(
               css_class="blog-form-field__textarea")
       )

``views.py``

.. code-block:: python

   @view_config(route_name='blog_create',
                renderer='blog/edit.jinja2')
   @view_config(route_name='blog_action', match_param='action=edit',
                renderer='blog/edit.jinja2')
   def blog_create(request):
       form = get_form(request)
       if request.method == 'POST':
           try:
               values = form.validate(request.POST.items())
           except deform.ValidationFailure as e:
               return {'form': e.render(),
                       'action': request.matchdict.get('action')}
           if request.matchdict['action'] == 'edit':
               article = Session.query(Article)\
                   .filter_by(id=request.matchdict['id']).one()
               article.title = request.POST['title']
               article.content = request.POST['content']
           else:
               article = Article(**values)
           Session.add(article)
           return HTTPFound(location=request.route_url('blog'))
       values = {}
       if request.matchdict['action'] == 'edit':
           values = Session.query(Article)\
               .filter_by(id=request.matchdict['id']).one().__dict__
       return {'form': form.render(values),
               'action': request.matchdict.get('action')}

Полный код
~~~~~~~~~~

.. code-block:: python

   import deform
   from pyramid.httpexceptions import HTTPFound, HTTPNotFound
   from pyramid.view import view_config
   from pyramid_sqlalchemy import Session

   from .forms import get_form
   from .models import Article


   @view_config(route_name='blog',
                renderer='blog/index.jinja2')
   def index_page(request):
       page = int(request.params.get('page', 1))
       paginator = Article.get_paginator(request, page)
       return {'paginator': paginator}


   @view_config(route_name='blog_article', renderer='blog/read.jinja2')
   def blog_view(request):
       id = int(request.matchdict.get('id', -1))
       article = Article.by_id(id)
       if not article:
           return HTTPNotFound()
       return {'article': article}


   @view_config(route_name='blog_create',
                renderer='blog/edit.jinja2')
   @view_config(route_name='blog_action', match_param='action=edit',
                renderer='blog/edit.jinja2')
   def blog_create(request):
       form = get_form(request)
       if request.method == 'POST':
           try:
               values = form.validate(request.POST.items())
           except deform.ValidationFailure as e:
               return {'form': e.render(),
                       'action': request.matchdict.get('action')}
           if request.matchdict.get('action', '') == 'edit':
               article = Session.query(Article)\
                   .filter_by(id=request.matchdict['id']).one()
               article.title = request.POST['title']
               article.content = request.POST['content']
           else:
               article = Article(**values)
           Session.add(article)
           return HTTPFound(location=request.route_url('blog'))
       values = {}
       if request.matchdict.get('action', '') == 'edit':
           values = Session.query(Article)\
               .filter_by(id=request.matchdict['id']).one().__dict__
       return {'form': form.render(values),
               'action': request.matchdict.get('action')}


   @view_config(route_name='blog_action', match_param='action=delete')
   def blog_delete(request):
       article = Session.query(Article)\
           .filter_by(id=request.matchdict['id']).one()
       Session.delete(article)
       return HTTPFound(location=request.route_url('blog'))


   @view_config(route_name='auth', match_param='action=in', renderer='string',
                request_method='POST')
   @view_config(route_name='auth', match_param='action=out', renderer='string')
   def sign_in_out(request):
       return {}
