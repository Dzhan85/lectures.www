*************************
Реляционная модель данных
*************************

.. note:: А. Левин:
  `Базы Данных: реляционные особенности и их практический смысл <http://geofaq.ru/art/master/dbr.htm>`_

Базы данных имеют в основе строгую математическую модель, почти все – реляционную,
с корнями в теории множеств.  Применяется эта модель везде, где есть формализованная информация,
вплоть до построения общения в сети. Разумеется, задействована она и в геотехнологиях.
При разработке Баз Данных (БД) крайне важно участие специалистов-экспертов по конкретной области знаний.
Даже профессиональные разработчики жалуются, что построение «хороших» БД не поддаётся чистой науке,
а требует изрядной доли интуиции. Только тогда БД может быть грамотно спроектирована, тонко настроена,
будет работать четко и развиваться непротиворечиво. Однако специалисты эти должны иметь четкое представление
о модели данных, о принципах работы математического аппарата, заложенного в основу БД. Отсюда и возникла
эта лекции, об основах реляционной модели данных – специалистам-практикам.

Часть 1: основные реляционные особенности, теория
=================================================

Введение
--------

**Реляционная модель данных** представляет интерес как наиболее проработанная математически.
Прочие модели либо имеют исторический интерес, либо узкую область применения, либо представляют собой
развитие реляционной модели.

Название «реляционная» происходит от математического термина *отношение*, *relation*.
Это аналог таблицы в теории баз данных. Термин не очень понятный: набор данных воспринимается как некое
«взаимоотношение». Другие термины реляционной модели звучат более удачно – «*домены*», «*атрибуты*»,
«*кортежи*». Однако даже теоретики часто говорят вместо них: «типы данных», «столбцы», «строки»,
что уж говорить о разработчиках и простых пользователях! Тем не менее, даже подменяя термины, разницу
между ними нужно понимать.

**Данные**, **информация**, **сведения**. Чтобы разобраться в базах данных, сначала нужно понять, что
такое, собственно, сами данные? Чем они отличаются от не-данных, от просто информации? Являются ли бумажные
листы данными или просто сведениями? Могут ли «твердые носители» составлять часть БД, как это часто
приходится слышать? Стоит ли вставлять в БД космоснимки, чертежи, видео? Станут ли они от этого «данными»,
то есть органичной, работоспособной частью БД, или нет? Данные и информация, данные и сведения, в чем разница?

Интуитивно понятно, что данные – не вся, но лишь организованная часть информации. Остальную, неорганизованную
часть можно называть просто «сведениями». Например, набор паспортов людей уже почти что данные, поскольку
используются бланки одного формата. Изображения номеров домов и знаков, как в reCaptcha – это информация,
поскольку заранее неизвестен ни размер изображений, ни ракурс. Есть **предметная область**, а есть различные
способы ее отображения – каталоги, паспорта, фотографии, чертежи, словом – информация. Для
автоматизированных способов обработки, например, для поиска, важно, насколько упорядочены эти сведения.
Причем важна упорядоченность не внешняя, например, обрезание фото по контуру, а по сути объекта, например,
классификация - автомобиль, самолёт, или поезд изображён на фотографии.  Еще лучше, если измерены размеры
объектов, известна модель. Еще лучше, если классифицированы марка, генетический тип, определена динамика.
Тогда можно проводить поиск, сортировку, обработку по организованным массивам, которые и называются
**данными**. Если по фотографии нельзя получить никаких таких сведений автоматически, то это не данные,
а лишь сведения для экспертов, которые извлекут данные потом, и то не факт, что извлекут.

Хранятся ли данные физически в БД или снаружи, файловым или табличным способом, не так уж важно: с точки
зрения системы все равно, поступают данные на момент запроса или записаны заранее в некие электронные
структуры. Важна степень упорядоченности, однозначность и эффективность.

**Сведения** можно рассматривать как отдельные папки, альбомы с фотографиями, для которых БД может играть
роль каталога. Сами папки могут быть доступны «по каталогу» путем заказа. Способы и сроки обработки такой
информации уже кардинально другие, результат обработки неоднозначен, зависит от прочтения, поэтому эта часть
информации не относится к данным, где бы она физически ни хранилась. Просто отсканировать фотографии мало для
базы данных, они так и останутся в ней чужеродным материалом, непригодным для опроса по критерию.

**Формализация информации**: процесс упорядочивания информации для обработки, превращения ее в данные обычно
сводится к формализации информации, что похоже на организацию системы бланков. Эта работа известна спокон
веку. В математике формализация – составление формул, когда упорядочивается способ расчета. В информатике -
упорядочивание самой информации, когда из разрозненных сведений возникает стройный набор рядов и колонок.
При создании БД это целый процесс. Он тем сложнее, чем меньше наработано «бланков» - готовых структур БД и
приемов их обработки. Не следует думать, что формализация - дело исключительно программистов или математиков
– наиболее разумные из них считают это наоборот, делом экспертов – знатоков предметной области. Чтобы
использовать данные, а тем более формализовать информацию, участвуя в разработке, надо знать правила
построения БД. Об этом и пойдет лекция.

Таким образом, «данные», «информация», «предметная область» - устоявшиеся термины информатики, а не просто
слова.  И если знатоками данных по праву могут себя считать математики, то знатоками информации и предметной
области являемся мы с вами. Для этого надо, однако, знать математические приемы работы. Приступим к их
изучению.

Множество как базисное понятие
------------------------------

**Понятие множества**: это всего лишь неупорядоченный набор уникальных значений.
Основные особенности множества это:

* **ограниченность**;
* **уникальность составляющих элементов**;
* **неупорядоченность**.

Эти важнейшие первичные свойства наследуются элементами реляционных баз данных. Зачем это вообще нужно,
тем более на практике? Набор есть набор, навалим, потом разберемся. Ну и упорядоченность должна быть, хотя
бы по номеру или времени создания… А вот и нет. Вся стройность «хороших» баз данных основана именно на
уникальности, вся гибкость систем – на неупорядоченности.

На самом деле свойства множества в математике сформулированы несколько по-другому, но смысл именно такой:
«должен быть способ отличить один элемент от другого», и «способ узнать, принадлежит ли элемент данной
совокупности». Наши две  «особенности»  вытекают из этих свойств. Применяют множества там, где наблюдается
«отсутствие связей между элементами», отсюда вытекает неупорядоченность как свойство самих данных, с которым
приходится мириться.

Что дают Базам Данных эти особенности множества?

.. figure:: /_static/databases/rdb/pic1.gif
   :align: center

   Рис. 1. Множество

**Ограниченность** изображают на рисунках как четкую границу, отделяющую «своих от чужих». Однако условия могут быть заданы по-разному. Например, «все целые числа», или «все числа от минус 0,5 до плюс 0.5». В обоих случаях элементов множества может быть бесконечно много, но всегда есть способ установить – число 3,1415 к обоим множествам не относится.

**Уникальность** позволяет не только искать и находить, но находить с гарантией, что эта находка будет единственной. Система поиска, таким образом, «строится» исходя из твердой уверенности, что данный объект – уникальный, правильно идентифицированный, и именно к нему относятся взятые в другом месте характеристики. Именно к этому товару по каталогу, например, относятся данные о скидках, а не к товарам вообще со сходным названием (а там разберемся), и не к месту на складе с неким адресом (там наверно где-то он и есть).

**Неупорядоченность** также важнейшее свойство. Система, получается, заранее не рассчитывает на некий порядок следования элементов. Таким образом, при любом обращении операция обойдет все элементы в множестве: это гарантировано на уровне системы. Понятно, что порядок при этом подразумевается и даже обязательно будет какой-либо, (если задуматься об уникальности!). Но это уже дело конкретной Системы Управления Базами Данных (СУБД), как оно там организовано на низком уровне или как значения сортируются на выходе. Для пользователя беспорядок гарантирован. И это свойство тоже идет от множества.

Далее мы увидим, что неупорядоченность и уникальность прослеживаются на разных уровнях организации реляционных БД, и всегда в тандеме. Не только для самих данных, но и для структур организации, для структур описания структур…

**Тип данных**, **операции со множествами**. Итак, условие задано, и появляется возможность в каждом конкретном случае понять, принадлежит ли элемент данному множеству, или находится за его пределами. Этим, по сути, задается **тип данных**. Для однотипных элементов появляется возможность сравнения, для сходных множеств тоже. Для этого все элементы множеств также должны быть **однотипны**. Над такими однотипными множествами возможны операции: **объединение**, **пересечение**, **вычитание** (оно же **дополнение**). Объединение на картинке это оба овала совместно, пересечение показано косой штриховкой, дополнение – точечным крапом.

.. figure:: /_static/databases/rdb/pic2.gif
   :align: center

   Рис. 2. Операции над множествами

Еще одна операция над множеством - **ограничение**, образование подмножества. Это выборка из множества по какому-либо дополнительному условию, что очень популярно в базах данных.

.. figure:: /_static/databases/rdb/pic2a.gif
   :align: center

   Рис. 2а. Ограничение (выборка)

Очень важно для реляционной теории такое действие, как сочетание множеств, когда каждый элемент одного множества сочетается с каждым элементом другого. В математике оно называется «**декартово произведение**». В результате образуется набор всех возможных пар (без ограничений).

.. figure:: /_static/databases/rdb/pic2b.gif
   :align: center

   Рис. 2б. Декартово произведение

Как можно догадаться, все это наследуется в полной мере реляционными структурами и методами, дополняется специальной прикладной математикой и имеет вполне определенный практический смысл.

Столбцы, строки, таблицы? Атрибуты, кортежи, отношения как множества
--------------------------------------------------------------------

С таблицами знакомы все, это основной элемент баз данных. Но лишь немногие подозревают, что таблицы – лишь внешнее отражение сложных внутренних структур БД. Говоря точнее, таблица – результат *ВЫВОДА* данных на экран, на принтер. Почти всегда таблица – результат поиска, отбора, то есть на экране мы видим не все данные, а лишь их часть в удобной табличной форме. Есть и другие форматы… Как же все устроено «внутри» реляционной БД?

**Атрибуты** это самый простой элемент структуры. В таблице мы их видим как названия столбцов. **Атрибуты** по сути это множество имён столбцов. Множество? Да, именно в математическом смысле. То есть, во-первых, уникальное, во-вторых, неупорядоченное.

*Уникальность* атрибутов обеспечивается именованием. Система должна следить за тем, чтобы не было двух одинаковых. Поскольку таблиц много, то обычно спереди добавляется приставка - имя таблицы.

*Неупорядоченность* никак специально не обеспечивается. Обычно в реальности атрибуты хранятся в том порядке, в каком были созданы. Однако любой другой порядок также имеет право на существование, поэтому уместно относиться к набору атрибутов именно как ко множеству.

.. figure:: /_static/databases/rdb/pic3.gif
   :align: center

   Рис. 3. Атрибуты

Обратите внимание, что множество атрибутов данной таблицы не сортировано. С точки зрения теории, последовательность *A.11*, *A.3*, *A7*, *A.1*, *A.9* столь же уместна, как и *A.1*, *A.3*, *A.7*, *A.9*, *A.11*. Разумеется, порядок использования атрибутов может задаваться при операциях, выборке, например:

.. code-block:: sql

    SELECT A.11, A.3, A7, A.1, A.9 FROM A

Собственно, вам предлагаются фразы языка SQL – Structured Query Language. Язык этот именно реляционный, и приводится для привыкания к реляционному стилю мысли, который он наглядно воплощает. Никакого упора на его изучение в тексте не будет, и если вам такой языковый подход покажется лишним, можете просто эти фразы пропустить – это дополнительный материал.

У атрибутов есть тип: в описании структуры таблицы обязательно указано, какой тип данных может быть присвоен атрибуту. Наиболее известные типы – числовой, текстовой, логический. Есть и другие типы, в том числе производные. Тип должен соблюдаться для всех значений атрибута. В таблице-справочнике городов, например, могут быть атрибуты:

* Номер/индекс города ID;
* Координаты X и Y;
* Население Z;
* Площадь H.

**Кортежи** это аналог строк в таблице. Каждый кортеж содержит несколько элементов по числу атрибутов таблицы, каждый элемент – одно значение, соответствующее одному атрибуту. Для разных атрибутов, разумеется, будут разные типы данных, но для одного и того же атрибута тип строго соблюдается в разных кортежах таблицы. Итак, кортеж – набор значений, но не просто обособленных, а значений, для каждого из которых известно, какому столбцу они принадлежат, какому атрибуту. Поэтому удобно считать, что кортежи содержат пары – имя атрибута и значение. В примере для справочника городов можно записать строку-кортеж так:

.. code-block:: sql

    ID: 151k X: 7541203 Y: 5724619 Z: 31,6 H: 17,5

В таком написании это больше похоже на кортеж, который есть не что иное, как **набор пар**: **атрибут-значение**. Не простых однако пар, но об этом чуть позже.

Является ли кортеж множеством? В руководствах это часто звучит. Однако сравнивать между собой вдоль по строке эти пары нельзя, значения ведь в парах разнотипные! Строго говоря, кортеж - не множество.  Это подчеркивается его названием, «cortege» переводится как цепочка, последовательность. Однако не следует думать, что значения в строках таблицы всегда выстроены – нет, как и для атрибутов, порядок следования может быть любой. Как правило, система обращается к значениям по именам атрибутов, а не по их порядку. В этом смысле изображения кортежей на рисунке равноправны.

.. figure:: /_static/databases/rdb/pic4.gif
   :align: center

   Рис. 4. Кортежи

Где же тогда еще задействованы множества? Где однотипность? Исходя из свойств атрибутов, каждая строка-кортеж похожа на другую – ведь во всех содержится одинаковое количество пар, и они сходны поатрибутно. Можно сказать, что ***все кортежи однотипны***. Конечно, это уже будет сложный тип, но вполне полезный и логичный – например, тип «Город», состоящий из Индекса, Координат, Населения.

Соблюдение однотипности кортежей очень важно для БД: если в таблице будут города без координат, с описанием вместо них, или без номера, или с неопределенным населением, согласитесь, это будет не БД, а сырые данные.

**Отношение** по сути и есть множество таких однотипных цепочек - кортежей. Именно множество, где каждый элемент имеет некоторый тип. Тип этот сложный, составной, можно его назвать тип «Город».

.. figure:: /_static/databases/rdb/pic5.gif
   :align: center

   Рис. 5. Отношение

Что за словечко вообще – «отношение»? Отношение чего к чему? Термин не выдуман специально для БД, он происходит из теории множеств, где обозначает сочетание одного множества с другим для составления пар, уже знакомое нам как декартово произведение. Одно исходное множество для сочетания мы видим – набор атрибутов, а другое? Это же просто значения, их бесчисленное множество. Множество?! Пожалуй, да, а вот бесчисленное ли? Об этом мы еще поговорим.

Итак, свойства отношений которые, как мы уже поняли, представляют собой множества однотипных элементов - кортежей:

* **Уникальность составляющих кортежей** – не должно быть двух одинаковых.
* **Неупорядоченность кортежей**. Порядок их следования, как можно догадаться, по умолчанию не определен.

Кроме того, в отношении соблюдается **неупорядоченность атрибутов**. Как во всем отношении, так и по кортежам. Как было сказано выше, обращение системы к значениям идет строго по именам атрибутов, И никогда - по их физическому порядку.

Здесь уместны комментарии – на самом деле, в математике неупорядоченность множеств не считается определяющим свойством. Известны упорядоченные множества, частично упорядоченные… Однако реляционная теория основывается на самых простых, «классических» множествах, именно неупорядоченных. Вы не можете, таким образом, ожидать от отношения некоего порядка строк, а вынуждены задавать его явно специальными командами. Среди них нет команды «по умолчанию» или по «физическому порядку», как в жизни. Всегда как порядок используется одна из колонок–атрибутов. Стоит позаботиться о том, чтобы в таблице такие колонки были - например, атрибут «широта» или «столица».

Итак, основные понятия реляционной теории – **атрибут**, **кортеж**, **отношение**.

В просторечии им соответствуют столбец, строка, таблица. Столбцы еще именуют колонками (columns), а строки – «записями» (records). Первое понятно, а второе имеет давнее происхождение, когда БД создавались последовательным вписыванием строк-значений, кропотливо и вручную.  Словом, в любых разработках, в описаниях БД, в терминологии SQL это синонимы, однако всегда под ними понимаются именно реляционные атрибуты, кортежи, отношения, а не наоборот.

Необходимо вкратце сказать о связи этих понятий с предметной областью:

* **Атрибут** обычно понимают как свойство некоего объекта;
* **Кортеж** представляет один какой-либо объект исследования, рассмотрения. Точнее, набор свойств объекта (что не одно и то же, если вдуматься).
* **Отношение**, таким образом, можно рассматривать как набор однотипных объектов, представляющий род, вид, тип, ассоциацию. В программировании это понятие фигурирует как «класс объектов». Отсюда понятно, что не следует делать таблицы на каждый город отдельно! Это класс однотипных объектов. Скорее теория требует декомпозиции на свойства, и каждому виду свойств должна соответствовать своя таблица. Например, улицы одного города лучше свести в единую таблицу.

Не всегда объект это физический предмет, разумеется. Это может быть некое событие, пперипись населения, например. Их проводят раз в несколько лет, и есть смысл их сгруппировать в отдельную таблицу. Бывают и другие разновидности объектов.  При разбиении на таблицы важно одно – увидеть набор взаимоувязанных свойств.

Типы данных? Домены!
--------------------

**Основные типы данных** в БД те же, что и в программировании:

* Целочисленный INTEGER;
* дробночисленный (с плавающей точкой) FLOAT;
* текстовой (символьный) различной длины CHAR, VARCHAR;
* логический (да/нет) BOOLEAN;
* временной (дата/время) (DATE/TIME).

Однако любых математических типов будет недостаточно, чтобы построить целостную базу данных и избежать несоответствий. Например, координаты XY  в системе Гаусса-Крюгера должны быть миллионы метров – не меньше и не больше. Население Z не может быть меньше 0, редкие виды растительности ограничиваются Красной Книгой… Это помогает не только отсекать возможные ошибки, но и заранее сузить область определения, задать ей практичные рамки. Такое пользовательское описание данных очень близко к понятию домена. Говоря **точнее**, домен это потенциально возможное множество значений. Domain в переводе означает «область», здесь смысл не расходится с переводом.

**Свойства домена**: очевидно, что домен является множеством, хотя в общем случае его значения нельзя просто перечислить. Зато всегда можно понять, в домене данное значение или нет. От множества, таким образом, наследуются свойства:

* **Ограниченность**: домен имеет границу, данные делятся на возможные и невозможные. Как и для множества, это не означает, что количество элементов конечное.
* **Уникальность**: можно сравнить одни элементы с другими и избежать дубликатов. Для одного отдельного домена это само собой разумеется.

.. figure:: /_static/databases/rdb/pic6.gif
   :align: center

   Рис. 6. Домены

По теории множеств **элемент кортежа** – не что иное, как сочетание атрибута со значением из домена. Домен - то самое упомянутое выше множество возможных значений для данного атрибута. Варианты задания условий могут быть разные, но всегда домен определяется, как подмножество одного из основных типов данных.

**Домен и атрибуты**. Итак, атрибуты должны быть увязаны с доменами, как говорят, «определены на некоем домене». Мало того, по теории БД понятие домена является краеугольным. На одном домене могут быть заданы несколько атрибутов. Например, домен «Глубин» может определять возможные значения для атрибутов «Глубина скважины», «Глубина обсадки», «Глубина установки фильтра», и даже «Глубина грунтовых вод», хотя это уже не техническая характеристика. Все эти атрибуты близки по диапазону, и вряд ли каждому нужен отдельный домен. Наоборот, задав их на одном домене, мы фиксируем возможность сравнивать эти характеристики (что глубже чего расположено, например). Это очень ценно для БД, поскольку отражает естественные соотношения, задает возможность взаимопроверок, сравнений.

**Атомарность значений**: теория настаивает, что значения домена должны быть простыми, атомарными, как говорят, то есть максимально несоставными. Это вообще-то не следует из теории множеств. Множества вообще могут содержать сложные элементы. Однако домены в этом плане более строги. Если домен задан как «Числовое значение от нуля до 200 метров», то в ячейку БД можно вписать только ОДНО числовое значение, а не два и не три вместе, как варианты.  Иначе как будут процедуры сравнивать эти числа? Проверять уникальность? Словом, одно значение - это один тип, а два вместе – уже пара значений, принципиально другой тип элемента.

Некоторые системы, однако, пользуются неатомарными значениями, разрешая последовательности и даже вложенные таблицы в качестве значений, но реляционными, в класическом понимании, считаться они не могут.

**Естественность доменов**. Даже теоретики БД признают, что домены должны нести смысловую нагрузку. Можно, конечно, определить домен как числовой тип данных «от и до» и на этом успокоиться. Однако куда полезнее относиться к домену, как к некоей группе параметров описания предметной области, к некоему смысловому понятию. Например, домен «Координаты», «Азимуты», «Температуры», «Глубины» и тому подобные.

Одного только названия и математического условия для домена может оказаться недостаточно. Например, площади городов от 0 до 200 км и площади процессоров от 14 до 50 нм вряд ли разумно считать одним доменом. Разные единицы измерения, способы, разная дискретность, вообще разные природные среды, ну и главное - трудно представить необходимость сравнения этих двух параметров между собой. Словом, не только условие важно, а все, что формулирует некую часть предметной области – описание, точность измерения, способ и т.д., но в первую очередь – естественный смысл.

Именно поэтому разработчиками баз данных домен признается как непростое понятие, требующее экспертной проработки. Однако, как правило, многие сферы предметной области уже достаточно формализованы, имеют готовые понятия и справочники.

**Ограничить излишние сравнения между атрибутами**, таким образом – основное назначение доменов. С другой стороны, можно сказать: «наметить возможные сравнения между нужными атрибутами»! И не только в одной БД - если в разных массивах данных описаны сходные домены – координаты в одной системе, температуры по Цельсию, глубины от поверхности в метрах, то понятно, что вполне возможно их значения сравнивать, сопоставлять между собой, совместно анализировать! Таким образом, ограничения оборачиваются свободой действий, свободой манипуляции с данными.

Первичный ключ, внешний ключ, связи
-----------------------------------

Уникальность строк-кортежей должна обеспечиваться в таблице, помните? В связи с этим **первичный ключ** – *primary key* - очень важное понятие, можно сказать «ключевое». Теоретически это набор значений, который однозначно идентифицирует данный кортеж. Точнее сказать, набор атрибутов отношения, минимально необходимый для идентификации. В теории допустимо, чтобы хоть одно значение различалось, в самой последней колонке, например. Однако мы знаем, что в реальности есть свойства важные, основные, а есть вспомогательные, несущественные. На практике удобно заранее определить небольшой набор признаков, существенных для описания объекта предметной области. Это и будет первичный ключ. Он может быть простой – из одной колонки, и составной – из нескольких. В принципе возможны таблицы, где все колонки входят в первичный ключ, все признаки существенны.

Первичный ключ составляет стержень таблицы, и любая СУБД имеет технические средства для его реализации. После назначения колонок первичным ключом уникальность по нему отслеживается автоматически. Система не позволит создать две строки с одинаковыми значениями первичного ключа.

Практический смысл первичного ключа очевиден: объект предметной области однозначно описывается с помощью набора атрибутов таблицы. Если меняется понимание объекта, меняется и этот набор атрибутов.

**Классы объектов** предметной области, можно сказать, моделируются с помощью первичных ключей. Первичный ключ фиксирует самое главное в объекте, его уникальную сущность. Остальные поля можно считать «просто атрибутами», «атрибутикой», как часто говорят.

Пропущенные значения (NULL)
---------------------------

Базы данных разрешают пропущенные значения, обозначая их словечком «NULL» - «не известно». Казалось бы, что тут необычного?  В таблицах и должны быть пробелы, куда от них денешься? Однако с точки зрения реляционной теории это не так уж очевидно. Значения атрибута, как мы знаем, должны быть однотипны. Можно ли сравнить любое целочисленное значение с NULL'ом? Значение -1 (минус один) будет больше NULL или нет? Ответ один – NULL, то есть опять-таки «не известно». Понятно, что это принципиально другой, особый тип данных. Очевидно, что это ведет к усложнению логики, ведь на любой вопрос к ячейке может быть теперь не два, а три ответа – «ДА», «НЕТ» и «не известно». В реальности так и происходит – команды СУБД содержат особые фразы для условий вида «IS NOT NULL». Теория их запрещает во многих случаях, например, в составе первичного ключа, и все системы за этим неукоснительно следят.

Внешние ключи и связи
---------------------

**Внешний ключ** – *Foreign key* - служит для связи таблиц. Это значения из одной таблицы, по которым можно однозначно привязаться к другой. Точнее говоря, для отношения внешний ключ - это опять-таки набор определенных заранее атрибутов. Например, в таблице точек наблюдений может быть атрибут «Административный Район», где для каждой точки проставлен код района, которому она принадлежит. Имеется таблица-справочник административных районов, в которой каждый район описан отдельной строкой. Для каждой точки по коду района можно найти его название и другие характеристики. Можно вообще соединить две таблицы в одну по этим ключам. Говорят, что атрибут «Район» – внешний ключ, ссылающийся на другую таблицу. Колонка ID в той, второй таблице, должна быть обязательно первичным ключом, иначе могут случайно сыскаться два одинаковых кода района в разных строках и система даст сбой, не сумеет однозначно привязаться.

.. figure:: /_static/databases/rdb/pic7.gif
   :align: center

   Рис. 7. Внешний ключ – Foreign key

Таким образом, на одну точку обеспечивается одно значение, одна строка в таблице РАЙОНЫ. Наоборот, точек к такому району может относиться множество, и связь называется «один-ко-многим», это наиболее распространенный тип связи. На диаграммах конец связи «ко многим» обозначается разветвлением, стрелкой или знаком бесконечность.

Итак, *внешний ключ должен ссылаться на первичный ключ* другой таблицы. В своей таблице он может быть обычным атрибутом, а может входить в состав первичного ключа, это заранее не известно. Например, если в таблице точек нумерация не сквозная по области, а порайонная, то атрибут «Район» логичным образом войдет в первичный ключ. К его внешней функции это не будет иметь прямого отношения.

Понятно, что первичный ключ может быть составным, а внешний ключ? Тоже может. Например, коды административных районов не обязаны быть уникальными, и могут повторяться в разных областях (субъектах федерации). Тогда первичный ключ таблицы районов будет «Код района» и «Код области», и на диаграмме связей мы увидим между таблицами две линии. Словом, система ключей достаточно гибкая, чтобы отражать любые варианты идентификации объектов предметной области. На этапе проектирования вполне достаточно сказать, что мол «к таблице точек привязаны районы», а с конкретными ключами разобраться позднее.

Не исключен также даже случай, когда и внешний ключ и первичный ключ связи один-ко-многим расположены в одной таблице. Связь таблицы «с собой же» нужна, чтобы моделировать соподчинение каких-либо однородных объектов – сотрудников, брендов и т.п. Для каждой починенной реки указывается главная, куда она впадает, например:

.. figure:: /_static/databases/rdb/pic8.gif
   :align: center

   Рис. 8. Связь таблицы «с собой же»

Таким компактным образом в реляционной БД может храниться иерархическая структура. Система первичных и внешних ключей, таким образом, составляет основу структуры БД, ее каркас.

Первичный ключ определен на каком-либо домене. Чтобы связь работала четко, на этом же домене должен быть определен и внешний ключ. В нашем примере это очевидно: набор кодов административных районов должен быть один и тот же, а не для разных областей. Идя далее, можно говорить, что к любому первичному ключу потенциально возможна связь, и соответственно, на его домене, скорее всего, будет основан внешний ключ в другой таблице. Такие «ведущие» домены особенно важны – ведь от них зависит структура не только таблиц, но и всей БД!

Нормализация
------------

Выше мы видели примеры, когда таблица не вполне соответствует требованиям реляционной теории. Содержит неатомарные значения, например, или объекты относятся к разным типам. Теоретически проработана методика, как поступать с такими таблицами. Описаны первая нормальная форма, когда значения всех атрибутов атомарны. Математически строго определены вторая нормальная форма, третья и так далее, как результаты улучшения предыдущих форм. Это улучшение называется **нормализацией**.

Как происходит нормализация? Уже приводились примеры неатомарности значений. Допустим, в какой-то колонке встречаются два значения вместо положенного одного (по сути это и не реляционное отношение вовсе, а сырые данные). Нужно разделить колонку на две. Разумеется, каждому значению придется придать смысл – максимальное значение и минимальное, среднее и максимум, и т.п. Но откуда взять этот смысл? Теория вам этого не скажет, математика не поможет, тут потребуется анализ данных, а точнее, исходной информации экспертом. На этом простом примере видно, что вся теория нормализации в реальности упирается в тщательную работу с первоисточниками, в грамотную формализацию. Мало того – на деле выходит, что теорией этой пользоваться опасно. Однако, с другой стороны, для проведения нормализации вполне достаточно здравого смысла, опыта и интуиции эксперта. Ведь когда, на каком этапе проекта делить колонку надвое, тоже важно! Если такой случай один на сто тыщ, ясно, что он погоды не делает - не лучше ли просто его игнорировать (ввести только среднее), пока такие исключения не накопяться? А тогда уж вводить в БД не только «max» и «min», а полные ряды наблюдений по совершенно другой системе.

В каких именно случаях и какая нужна нормализация, будет показано дальше.

Часть 2. Практический смысл реляционных особенностей БД
=======================================================

Домены и ограничения
--------------------

Домены широко известны, однако специальные средства для их реализации в СУБД обычно примитивны: немногие системы поддерживают понятие домена явно. Однако тем не менее в любой, даже самой простой реляционной СУБД найдутся достаточные способы для реализации доменов. Как же они задаются технически? Прежде всего, как типы данных пользователя, производные от основных. Берется, например, числовой тип, и дополнительно накладывается ограничивающее условие, «больше», «меньше» или сразу «в каких пределах».

**Ограничения** математического типа можно задавать в любой СУБД. В структуре таблиц можно задавать ограничения «от» и «до» любым числовым атрибутам, это уже шаг к полноценным доменам. Ограничив значения от нуля до 50 м/с, получаем домен скоростей ветра. Кроме того, возможны и сложные условия, и даже процедурные проверки.

Другим видом задания домена является **перечисление**, как вы уже видели выше. Обычно оно реализуется в виде списков, например, перечисление всех возможных румбов: N, NE, E, SE, S, SW, W, NW. Такие законченные списки хранятся в отдельных местах, порой таких, что их трудно пополнять и редактировать. Однако в общем случае список не может состоять из одной колонки, и не может считаться стопроцентно законченным. Классификация, как и в реальности, должна пополняться, редактироваться, адаптироваться, совершенствоваться. Для такой работы в реляционных БД всегда есть готовые структуры – сами таблицы! Мы знаем, что связь таблицы-списка с основной работает как ограничение, не дает вводить незарегистрированные значения, а только краснокнижные виды, например. Именно с помощью таблиц можно организовать домен более гибко – например, как список всех возможных видов фауны, с пометкой особо охраняемых по категориям. На практике при разработке БД выделяется особый класс таблиц – **справочники-классификаторы**, это и есть самый удобный способ задания перечисляемых доменов. Таблица видов флоры и фауны, административных единиц и т.п. Словом, для реализации доменов вполне подходят те же механизмы, что и для самих данных. В любом случае важно еще соблюдать какой-либо принцип именования и взаимоотношения доменов – он частенько отсутствует, и его приходится придумывать разработчику. Впрочем, это, скорее, вопрос дисциплины проектирования и программирования.

Первичность доменов в разработке не вызывает сомнения. На примере доменов ясно, насколько важно участие специалиста по предметной области уже на этом этапе разработки. Вообще этап проектирования доменов, как думается, должен идти раньше определения классов объектов и их конкретных свойств. Справочники и их наполнение вытекают уже из того, какая область знаний подлежит исследованию. Например, при геологических работах справочники горных пород, литологии, кодировки к ним надо готовить еще до самих работ, а тем более до составления БД. Так и обстоит дело там, где информатика на уровне, а степень формализации отрасли высока. К сожалению, часто приходится определять домены постфактум, по уже набранным сырым данным, сводкой из текстовых полей - как следствие – множество ошибок, несоответствий и нонсенсов.

**Структурная роль доменов**. Домены составляют основу хорошей реляционной БД, это ясно, поскольку они задают не только значения в одной колонке, но и возможность сравнений колонок, как бы устанавливая степень родства атрибутов, задавая степень сходства, намечая связи. Для досконально изученного района и формализованной области знаний можно представить заранее определённые домены, например, по готовым нормативам, инструкциям, справочникам и учебникам.

Родственные домены могут и должны составлять структуру, каркас хорошей БД. Например, виды растительности: они объединяются в роды,  возникает еще одна таблица. Логичным образом возникают семейства, отряды, типы… Если эти соподчиненные таблицы работают как домены, ограничивая значения только известными, это задает ни много ни мало, а модель предметной области в части растительности.

Другой пример моделирования предметной области – координаты XYZ. Если собрать домены координат и глубин в одной системе, то они определят пространство исследования. Если добавить еще и время, то таким образом будет заранее задана некая пространственно-временная модель. Для нее будут известны единицы измерения, может быть задана дискретность, описаны неоднородности (подрайоны, сезоны и т.п.). Таким образом, на основе взаимосвязанных доменов также возникает заранее удобная и полезная аппроксимация.

Можно осмелиться и сказать, что вообще конкретное условие, набор значений для доменов второстепенное дело. Важен в первую очередь естественный смысл, описанный «по-русски». Конкретные условия и наборы могут меняться со временем, но смысл должен оставаться и даже наследоваться другими смежными базами данных.

Несмотря смысловую прозрачность, мощность понятия «домен» скрыта как от пользователей, так от разработчиков, и, как следствие, этот реляционный инструмент используется недостаточно. В чем причина недооценки? Слишком многое в доменах оставлено на откуп «здравому смыслу». Мало свойств и правил, иными словами, домены не разработаны математически, и нет надежных приемов, точнее, они у каждого разработчика свои. В учебниках длиной 300 страниц доменам посвящается всего одна. Почти нет практических статей по вопросам доменов: системам предлагается полагаться на чутье и опыт разработчика.

Первичные ключи и индексы
-------------------------

Естественность первичного ключа также важна для правильного моделирования предметной области. Ведь первичный ключ – лишь отражение реальной идентификации объектов на практике.

Перекодировать все точки опробования искусственным номером несложно (так называемый искусственный ключ), но это не отменяет необходимости следить за естественной идентификацией объектов. Например, БД работников предприятия вполне может довольствоваться табельным номером как первичным ключом. При расширении предприятия на несколько регионов придется идентифицировать работников по номеру паспорта, ИНН. Для БД города или страны жители всегда  привязаны еще и по месту жительства, на всякий случай. Жителей планеты сложно идентифицировать и по месту, вводится, как мы знаем, биометрия. Ну а скрывающихся персонажей и по биометрии не вычислить, в таких базах обязательно фигурируют еще и особые приметы. Словом, нумерация как идентификатор возможна в пределах одной четко ограниченной стабильной системы, как только система станет шире или будет взаимодействовать с соседними, вопрос естественной идентификации возникнет со всей остротой. Слить БД двух разных предприятий по табельным номерам не удастся.

Реализуются первичные ключи через механизм индексации. Индексы - это специальные структуры, точнее – ряды уже обработанных данных и ссылок. Они служат для быстрой сортировки, но в том числе поддерживают и уникальность. В основу положена отлаженная математика, ее наиболее проверенные и эффективные методы, чтобы обеспечить работу первичного ключа на лету. Специально следить за ними пользователю не приходится, все работает автоматически и очень быстро.

.. code-block:: sql

    CREATE TABLE districts (
      id integer PRIMARY KEY,
      name text
    );

В команде SQL на создание таблицы объявление PRIMARY KEY означает, что в некоторых колонках таблицы (ID, например) не должно быть дубликатов и, кроме того, еще и пропущенных значений.

Возможно задать отдельно «уникальный индекс» еще по каким-то колонкам, кроме первичного ключа, «про запас» на будущее, например, по названию NAME.

Кроме слежения за уникальностью индексы делают эффективной сортировку, и почти все СУБД создают индексы автоматически, по мере надобности.

Принцип целесообразности в разработке БД подскажет, когда понадобится детализация первичного ключа, и каких дубликатов можно ожидать. И если явные дубликаты не допустит система, то следить за скрытыми, потенциальными – дело администратора БД и экспертов.

Внешний ключ и связи
--------------------

Внешний ключ, по сути, задает связь между двумя таблицами. Для реализации связи нужно указать внешний ключ в одной таблице – это может быть любая колонка - и другую, связуемую таблицу. На практике эти два понятия, связь и внешний ключ, редко разделяются. Чаще всего они и задаются вместе, еще при создании таблицы, как ограничение со стороны внешнего ключа.
Пример организации связи между точками и районами на языке SQL будет выглядеть вот так:

.. code-block:: sql

    CREATE TABLE points (
      id integer PRIMARY KEY,
      x real,
      y real,
      z real,
      district integer REFERENCES districts
    );

Это автоматически означает, что в колонке *points.district*, объявленной внешним ключом, могут быть значения только из колонки *districts.id*.

Разумеется, порядок создания таблиц важен – сначала создается таблица *districts*, которая «ничего не знает» про *points* (это логично, если вдуматься – административные районы сто лет стояли, а точки лишь потом понатыкали ). Поскольку при создании *points* ссылается на *districts*, то она создается во вторую очередь. Результатом применения двух вышеприведенных команд SQL будет пара связанных таблиц:

.. figure:: /_static/databases/rdb/pic9.gif
   :align: center

   Рис. 9. Связь двух таблиц

Разрешается задать связь и потом, после создания и даже наполнения таблиц: возможны всякие варианты. Однако хорошим тоном считается задавать все связи сразу, хотя бы приблизительно. Тип связи («один-ко-многим» или «один-к-одному») не задается пользователем, он вычисляется системой, исходя из того, где первичный ключ, а где – внешний. В нашем случае в таблице *points* внешний ключ, следовательно, здесь один и тот же код района может повторяться много раз, хоть в каждой строке, значит, это сторона связи = «много». В таблице *districts* код района *id* – первичный ключ, в этой колонке никак не может быть одинаковых значений, это сторона связи «один».

Получается, однотипные ключевые атрибуты входят в разные таблицы, задавая связи или обозначая сравнение данных. В таком случае  важно, чтобы ключевые колонки были однотипны, определены на одном наборе, словом, сопоставимы не только как типы данных, но и по здравому смыслу. Разумно это отслеживать в БД через домены. В идеале, система должна допускать установление связи, только когда оба соединяемых атрибута принадлежат одному домену. Как говорят, «определены на одном домене».

**Соединение для запроса** может реализовываться временно, в момент проведения операции, как простое математическое соединение двух таблиц по каким-либо колонкам, подобно застежке-молнии. Это не структурная связь, она не требует ключей в общем случае.

Требования однотипности для любых связей очевидны. Если такая связь, например, идет по численным полям, то крайне важно, чтобы в соответствующем месте были зафиксированы еще и такие характеристики этих параметров, как **единицы измерения и дискретность параметра**. Стратегически важные параметры пространства-времени разумно дискретизировать заранее.

В частном случае, когда идет простое сравнение значений двух колонок, и выясняется, кто больше, а кто меньше, дискретность кажется излишней. Однако связи реализуются через соединение по условию равенства, и в этом случае очевидно, что вопросы единиц измерения, дискретности связуемых параметров должны отслеживаться через домен хотя бы для основных параметров БД.

Вопросы дискретности и единиц измерения должны быть заложены в методику исследований, разумеется, но так редко бывает на практике.

Итак, любая связь в БД должна задаваться как отражение естественных взаимоотношений через строго заданный домен. Это формализует предметную область и «дисциплинирует» данные по проекту.

Однако естественная связь, как правило, требует не простого, а составного ключа, из нескольких параметров.  Как быть на практике? Составной внешний ключ неудобен для работы, тормозит систему и усложняет схему. На практике его стараются избежать, например, в нужный момент перекодировать значения трех ключевых колонок одним кодовым номером. На практике это реализуется через механизмы автонумерации и индексов.

Целостность и каскадные операции
--------------------------------

**Целостность сущностей** – объектов определяется первичными ключами таблицы. Первичный ключ должен быть естественным. Если работает автономер, то естественный первичный ключ реализуется через уникальный индекс. Такая целостность не дает вводить дубликаты, гарантирует уникальность объектов и отсутствие пробелов для любых операций.

**Целостность связей** формирует структуру всей БД. В примере выше с внешним ключом видно, что таблица *districts* «главнее», поскольку *points* ссылается на нее. Очевидно, что если один из районов исчезает (например, упразднен), то значения в *points* не могут продолжать ссылаться на несуществующее значение, требуются какие-то изменения. Это и есть принцип ссылочной целостности. Система в общем случае не даст удалить район, пока не решены ссылки в *points*.  Ссылки должны быть либо удалены, либо исправлены заранее на другой район.

Можно пользоваться таким механизмом целостности, как «каскадные операции». Если механизм включен, то при удалении основной сроки удаляются связанные с ней. Второй вариант – каскадное переименование, при изменении кода района в таблице *districts* в таблице *points* он тоже автоматически меняется.

**Целостность понятий** не менее важна и для БД в целом, и для отдельных операций. Это естественная смысловая, или, как говорят, «**семантическая целостность**». Она должна быть реализована и через первичные ключи, и через связи, и через домены.

Недостатки реляционной модели
=============================

* **Строгость структур страдает негибкостью**. Реляционная модель волей-неволей задает строгую однотипность объектов в таблице, тогда как в реальности все они разные. NULL значения помогают примириться с обязательным набором атрибутов, но постоянно стоит дилемма – вынести объекты другого типа за рамки или рамки расширить?

* **Сильная зависимость структур от данных**. Возможности работы реляционными способами, особенно структуры данных, сильно зависят от состава данных, от их статистики. Многие известные модели данных можно уместить в рамках реляционных структур, например, иерархические, как было показано выше. Однако варианты реализации могут быть разные для разных массивов данных. И если данные меняются, приходится менять и структуры. Это довольно болезненный процесс для многих систем, где такие «мутации» не запланированы заранее.

Практически все реляционные особенности БД, унаследованные от множеств, несут весьма точный и вполне конкретный смысл, довольно удобный для моделирования предметной области. Несмотря на то, что понятиям реляционной модели, таким как «атрибут», «отношение», «домен» уже несколько десятков лет, они вполне применимы для формализации современных данных.
